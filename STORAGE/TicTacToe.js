import React, { useState, useEffect } from 'react';
import axios from 'axios';
import './TicTacToe.css'; // Ensure CSS adjustments for scoreboard are included

const TicTacToe = ({ quboCode, log }) => {
  const [gameSetup, setGameSetup] = useState(false);
  const [player1Type, setPlayer1Type] = useState('Human');
  const [player2Type, setPlayer2Type] = useState('CPU');
  const [player1Difficulty, setPlayer1Difficulty] = useState('Easy');
  const [player2Difficulty, setPlayer2Difficulty] = useState('Easy');
  const [unlockedDifficulties, setUnlockedDifficulties] = useState(['Easy']);
  const [currentPlayer, setCurrentPlayer] = useState('X');
  const [cells, setCells] = useState(Array(9).fill(''));
  const [playerWins, setPlayerWins] = useState({ X: 0, O: 0 });
  const [turnIndicator, setTurnIndicator] = useState('');
  const [gameOver, setGameOver] = useState(false);
  const [nextGameReady, setNextGameReady] = useState(false);

  const MAX_WINS_DISPLAY = 3;
  const MOVE_DELAY = 1000;

  useEffect(() => {
    if (gameSetup && !gameOver) {
      if (currentPlayer === 'X' && player1Type === 'CPU') {
        setTurnIndicator('Player 1 (CPU) is making a move...');
        setTimeout(() => handleCPUMove(player1Difficulty), MOVE_DELAY);
      } else if (currentPlayer === 'O' && player2Type === 'CPU') {
        setTurnIndicator('Player 2 (CPU) is making a move...');
        setTimeout(() => handleCPUMove(player2Difficulty), MOVE_DELAY);
      } else if (currentPlayer === 'X' && player1Type === 'Quantum CPU') {
        setTurnIndicator('Player 1 (Quantum CPU) is making a move...');
        setTimeout(fetchQuantumMove, MOVE_DELAY);
      } else {
        setTurnIndicator(`It's ${currentPlayer === 'X' ? 'Player 1' : 'Player 2'}'s turn`);
      }
    }
  }, [currentPlayer, gameSetup, gameOver]);

  const startGame = () => {
    setGameSetup(true);
    setCells(Array(9).fill(''));
    setCurrentPlayer('X');
    setTurnIndicator("It's Player 1's turn");
    setGameOver(false);
    setNextGameReady(false);
    log('> Game started\n\n');
  };

  const handleCellClick = (index) => {
    if (cells[index] || !gameSetup || gameOver) return;

    makeMove(index);
  };

  const makeMove = (index, player = currentPlayer) => {
    const newCells = [...cells];
    newCells[index] = player;
    setCells(newCells);
    log(`> Placed ${player} at cell ${index}\n\n`);

    if (checkWinner(newCells)) {
      setGameOver(true);
      alert(`${player} wins!`);
      handleWin(player);
    } else if (checkDraw(newCells)) {
      setGameOver(true);
      alert("It's a draw!");
      prepareNextGame();
    } else {
      setCurrentPlayer(player === 'X' ? 'O' : 'X');
    }
  };

  const handleWin = (player) => {
    setPlayerWins((prevWins) => {
      const updatedWins = { ...prevWins, [player]: prevWins[player] + 1 };
      if (updatedWins[player] === MAX_WINS_DISPLAY) {
        alert(`${player === 'X' ? 'Player 1' : 'Player 2'} wins the series!`);
        resetScoreboard();
        resetToSetup();
      } else {
        prepareNextGame();
      }
      return updatedWins;
    });
  };

  const prepareNextGame = () => setNextGameReady(true);

  const startNextGame = () => {
    setCells(Array(9).fill(''));
    setCurrentPlayer('X');
    setGameOver(false);
    setNextGameReady(false);
    setTurnIndicator("It's Player 1's turn");
  };

  const resetScoreboard = () => {
    setPlayerWins({ X: 0, O: 0 });
  };

  const resetToSetup = () => {
    setGameSetup(false);
    setCells(Array(9).fill(''));
    setCurrentPlayer('X');
    setGameOver(false);
    setNextGameReady(false);
    log('> Game reset to setup screen\n\n');
  };

  const handleCPUMove = (difficulty) => {
    const availableCells = cells
      .map((cell, index) => (cell === '' ? index : null))
      .filter((index) => index !== null);

    const randomCell = () =>
      availableCells[Math.floor(Math.random() * availableCells.length)];

    const move = difficulty === 'Easy' ? randomCell() : randomCell(); // Extend logic for difficulty
    makeMove(move);
  };

  const fetchQuantumMove = async () => {
    // Fallback for createQuboForSingleMove
    const fallbackCreateQuboForSingleMove = (board) => {
      console.warn('Using fallback createQuboForSingleMove function.');
      return {
        linear: { 0: -1, 1: -1 },
        quadratic: { '0,1': 2 },
      };
    };
  
    try {
      // Dynamically evaluate Blockly code within a controlled scope
      const executeBlocklyCode = new Function('cells', `${quboCode}; return createQuboForSingleMove;`);
      const createQubo = executeBlocklyCode(cells) || fallbackCreateQuboForSingleMove;
  
      // Generate QUBO from the evaluated function
      const qubo = createQubo(cells);
      log('> QUBO Generated by Blockly Code\n\n');
  
      // Send QUBO to the Quantum Server
      const response = await axios.post('http://localhost:8000/quantum', qubo);
  
      if (response.data && response.data.solution !== undefined) {
        makeMove(response.data.solution, 'X');
        log(`> Quantum Server placed X at cell ${response.data.solution} based on QUBO\n\n`);
      } else {
        throw new Error('Invalid response from Quantum Server.');
      }
    } catch (error) {
      console.error('Quantum Server Error:', error.message);
      log(`> Quantum Server Error: ${error.message}\n\n`);
    }
  };  

  const checkWinner = (currentCells) => {
    const winningCombos = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6],
    ];

    return winningCombos.some((combo) =>
      combo.every((index) => currentCells[index] === currentPlayer)
    );
  };

  const checkDraw = (currentCells) => currentCells.every((cell) => cell);

  return (
    <div className="container">
      <h1>Tic Tac Toe</h1>
      {gameSetup ? (
        <>
          <div className="scoreboard">
            <div>Player 1 (X): {playerWins.X}</div>
            <div>Player 2 (O): {playerWins.O}</div>
          </div>
          <div className="board">
            {cells.map((cell, index) => (
              <div
                key={index}
                className="cell"
                onClick={() => handleCellClick(index)}
              >
                {cell}
              </div>
            ))}
          </div>
          <p className="turn-indicator">{turnIndicator}</p>
          {nextGameReady && (
            <button onClick={startNextGame}>Start Next Game</button>
          )}
          <button onClick={resetToSetup}>Reset to Setup</button>
        </>
      ) : (
        <div className="setup">
          <h2>Game Setup</h2>
          <label>
            Player 1 (X):
            <select
              value={player1Type}
              onChange={(e) => setPlayer1Type(e.target.value)}
            >
              <option value="Human">Human</option>
              <option value="CPU">CPU</option>
              <option value="Quantum CPU">Quantum CPU</option>
            </select>
          </label>
          {player1Type === 'CPU' && (
            <label>
              Difficulty:
              <select
                value={player1Difficulty}
                onChange={(e) => setPlayer1Difficulty(e.target.value)}
              >
                {unlockedDifficulties.map((level) => (
                  <option key={level} value={level}>
                    {level}
                  </option>
                ))}
              </select>
            </label>
          )}
          <label>
            Player 2 (O):
            <select
              value={player2Type}
              onChange={(e) => setPlayer2Type(e.target.value)}
            >
              <option value="Human">Human</option>
              <option value="CPU">CPU</option>
            </select>
          </label>
          {player2Type === 'CPU' && (
            <label>
              Difficulty:
              <select
                value={player2Difficulty}
                onChange={(e) => setPlayer2Difficulty(e.target.value)}
              >
                {unlockedDifficulties.map((level) => (
                  <option key={level} value={level}>
                    {level}
                  </option>
                ))}
              </select>
            </label>
          )}
          <button onClick={startGame}>Start Game</button>
        </div>
      )}
    </div>
  );
};

export default TicTacToe;